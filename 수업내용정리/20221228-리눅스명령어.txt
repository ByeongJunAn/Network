= Linux 표준 디렉터리 구조
실행파일, 일반text파일등을 잘 모르는 경우에는

file [해당파일의경로와파일명]
 어떤 파일인지 확인을 할 수가 있음

which [명령어]
 해당 명령어가 어디에 위치하는지를 알수가 있음


bin(binary): 2진파일 -> 실행파일  => /usr/bin 링크되어 있음
boot: 리눅스의 부팅관련 파일, 커널, grub(부트관리자)
dev(device): 장치관련 파일이 존재
             시스템의 모든 장치가 파일로 표현
             tty: cli를 시스템에 연결된 키보드/마우스 직접연결
             pts: putty나 터미널을 프로그램 원격접속
             /dev/null
home : root 제외한 사용자의 홈폴더가 해당 사용자의 id로 만들어짐
       (default)

mnt(mount): 리눅스는 디렉터리에 하드디스크를 마운트하는 형태로 인식하도록 되어 있음, 윈도우의 c: d: 드라이브의 개념이 존재하지 않음, mnt 폴더에 디렉터리를 생성하거나 mnt 폴더 자체를 임시로 마운트를 시키는 디스크를 위해 사용하도록 만들어놓은 폴더

usr(user): 사용자들을 응용소프트웨어들이 설치되는 디렉터리

proc(process): 실행 중인 process의 CPU사용, 메모리 주소, 사용과 같이 시스템정보가 가상파일로 저장(실제 disk를 사용하지 않음) -> 그의 대부분이 읽기 전용

root: root(리눅스의 최고권한을 가진 user로 super user라고도 불림)의 홈디렉터리


etc: 리눅스의 모든 환경설정 파일들이 저장

var(variable): 수시로 업데이트되거나 변경이 되는 파일들을 위치
 주로 log 파일, http, mail, dns 등이 동작할 때 필요한 데이터가 저장되는 위치이기도 함

opt(option): 추가 SW 설치 주로 사용되는 디렉터리 
 
* 사용자 홈디렉터리는 root와 해당 사용자만 접근이 가능하도록 권한이 설정됨


* 윈도우/리눅스의 디스크 관련 차이점 
윈도우는 USB 연결하면 자동인식 -> 자동으로 마운트->드라이브문자
리눅스는 USB 연결하면 자동인식 -> 마운트가 자동되지 않음 -> 수동으로 마운트를 해줘야지만 연결이 됨

[root@localhost ~]# ls -liFh
total 40
134775233 -rw-r--r--. 1 root root     0 Dec 28 14:11 1234
202007200 drwxr-xr-x. 2 root root     6 Dec 28 14:12 a123/
134775234 -rw-r--r--. 1 root root     0 Dec 28 14:12 a123.txt
134847504 -rwxr-xr-x. 1 root root 38312 Dec 28 14:59 pwd*


inode 파일의 고유한 저장 id 값

파일종류: 
d 디렉터리 
- 일반파일(실행파일포함)
l 심볼릭 링크(바로가기)      

용량이 표시되는 출력의 경우 h 옵션(human readable)을 주면 K,M,G와 같이 천단위 기호가 붙어서 읽기가 편하게 됨

권한 rwx rwx rwx
     421 421 421 => 777
     421 4-1 4-1 => 755 (root 디렉터리 생성 시 기본권한)
                    775 (일반 사용자 디렉터리 생성 기본권한) 
     42- 4-- 4-- => 644 (파일 생성 시 기본 권한)

     r: 읽기, w: 쓰기, x: 실행 (eXcute)
     리눅스 실행파일 여부는 x 권한이 있느냐 업느냐로 따짐
     정확한 확인을 위해서는 file 명령어로 확인
     root는 권한설정을 무시
     디렉터리에서 rwx의 의미
      r: 디렉터리 목록 확인 권한
      w: 디렉터리 안에서 파일을 생성, 삭제, 수정하는 권한
      x: 디렉터리 내에 있는 항목을 읽을 수 있는 권한과 
         디렉터리 내로 진입할 수 있는 권한

     
= mkdir 현재 폴더를 기준으로 디렉터리를 생성할 수 있음

= 리눅스의 특수 문자[메타문자]들
1. history에서 사용
 ![history번호] :해당 번호의 명령을 실행
 !! :바로직전에 사용한 명령어를 재실행
 !-숫자: 마지막 명령으로부터 숫자만큼의 명령어를 재실행
 
2. 리눅스 다중 명령어 처리 특수 문자 (명령어 연결)
 | (파이프라인, vertical bar) : 
   앞의 명령의 결과를 뒷의 명령의 입력값으로 전달
 ; 명령과 명령을 연결 (연결된 명령어를 왼쪽부터 차례로 실행)
   for, if, case, while 
   (스크립트 처리용 명령을 사용할 때 주로 사용)
 && (and연산개념) 앞의 명령어가 정상 실행되면 뒷 명령 실행
 || (or연산개념) 명령을 왼쪽부터(앞부터) 실행 중에 에러가 나도 뒷 명령을 실행해주고 실행 중에 명령이 성공하면 뒤에 나오는 명령어는 처리하지 않음

 |와 &&를 가장 많이 사용

 | 출력 내용이 많을 때 more 또는 grep(특정문자를 찾아서 해당 문자 있는 행을 출력)명령에 많이 사용


3. 리눅스 쉘은 정규표현식을 사용할 수 있음
* 0개 이상의 문자 대체
? 1개의 문자 대체
[] 범위지정 시 사용 [A-Z|a-z]
{} 각문자열과 일치
^ 첫시작
$ 제일끝
[^] 해당 범위가 아닌 부정


4. 리눅스의 괄호기호
() - 함수 인수의 시작과 끝
   - 서브쉘 작성
   - 배열초기화

(()) 산술연산
{} 명령블록의 시작과 끝, 각종 변수의 존재 범위, 매개변수확장
   반복되는 문자열 목록 작성, 변수를 명확하게 식별
[] 배열 인덱스, 테스트 조건 (if문에서사용)

5. 입출력 리다이렉션
> 표준출력(1),에러(2)를 덮어쓰기
>> 표준출력,에러를 이어쓰기
< 표준입력 덮어쓰기
<< 표준입력 이어쓰기

6. \ : 메타문자의 의미를 제거


= 파일 관리 명령어 옵션
cp(copy), mv(move), rm(remove)
-i (interactive): 사용자 동의를 얻는 것
-r(R) (recursive): 하위 폴더
-f (force): 강제 (yes/no 없음)
-v (verbose): 상세 내역을 출력

cp -p(property) 해당 파일의 권한을 그대로 가지고 복사
 해당 명령을 사용하는 사용자의 권한으로 진행이 됨

= 리눅스의 링크 (디스크 용량을 감소시키기 위해 사용)
(1). 하드링크
 inode를 공유하는 링크로 서로 다른이름의 파일이 같은 파일 내용을 공유함 특정 파일이 삭제되도 다른 파일로 불러올 수 있음
(full clone과 같은 역할을 해준다라고 이해하면 편함)
ln [원본파일] [하드링크이름]
원본파일 = 링크파일

(2). 심볼릭 링크
 바로가기가 만들어지고 원본파일과 inode가 틀려짐
 원본이 삭제되면 링크파일을 열수가 없음
(link clone과 같은 역할을 해준다라고 이해하면 편함)

ln -s [원본파일] [심볼릭링크이름]

원본파일 <- 링크파일은 원본파일의 의존성을 가짐
